$schema: https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json
name: OSF
scopeName: source.osf
# Top-level patterns tried in order. Specific first!
patterns:
  # 1. Match indented property lines first (most specific based on indent)
  - include: '#node_properties'
  # 2. Match indented text blocks (also specific indent)
  - include: '#text_block'
  # 3. Match node declarations (specific keyword at start)
  - include: '#node_declaration'
  # 4. Match the header (less specific start pattern)
  - include: '#header'
  # 5. Match general quoted strings (can appear anywhere)
  - include: '#strings'
  # Include comments if you add them back


repository:
  comments:
    patterns:
      - name: comment.line.number-sign.osf
        match: '#.*$'  # Rule for the header line like 'apiVersion: dialogue/v1'
  header:
    patterns:
      - name: meta.header.osf
        # Match 'word:', optional whitespace, 'rest of line' at the start ^
        match: ^\s*([a-zA-Z_][a-zA-Z0-9_]*):\s*(.+)\s*$
        captures:
          '1': { name: entity.name.tag.osf }       # Style 'apiVersion' as a tag/key
          '2': { name: string.unquoted.value.osf } # Style 'dialogue/v1' as a value

  # Rule for 'node node_id:'
  node_declaration:
    patterns:
      - name: meta.node.declaration.osf
        # Match 'node', whitespace, 'node_id', ':' at the start ^
        match: '^(node)\s+([a-zA-Z_][a-zA-Z0-9_]*):\s*$'
        captures:
          '1': { name: keyword.control.osf }     # Style 'node' as a keyword
          '2': { name: entity.name.function.osf } # Style 'node_1' as an entity name

  node_properties:
    patterns:
      - name: meta.property.osf
        match: '^(\s+)([a-zA-Z_][a-zA-Z0-9_]*):[ \t]*(.*?)?[ \t]*$'
        captures:
          '1': { name: punctuation.whitespace.leading.osf }
          '2': { name: entity.name.tag.osf } # Key
          '3': # Value Capture Group
            name: meta.property.value.osf
            patterns:
              - name: meta.variable-access.osf # Try Object.Property First
                match: '([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_]*)'
                captures:
                  '1': { name: entity.name.type.class.osf }
                  '2': { name: variable.other.constant.property.osf }
              - include: '#strings' # Then Strings
              - name: string.unquoted.value.osf # Fallback
                match: '.+'

  property_variable_access:
    patterns:
      - name: meta.header.osf
        # Match Identifier, Dot, Identifier
        match: '([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z_][a-zA-Z0-9_]*)'
        captures:
          '1': # The Object/Variable Name (e.g., OliverVertran)
            name: variable.other.object.osf
          '2': # The Property Name (e.g., name)
            name: variable.other.property.osf

  text_block:
    # This whole block defines the multi-line indented text
    name: string.unquoted.block.osf # Base scope for the block content
    # Begin matching on the first line that has the block indentation (e.g., 4+ spaces)
    # Use positive lookbehind to ensure the PREVIOUS line ended with 'text:'
    # NOTE: Lookbehind is complex and not universally supported/performant in all TextMate engines.
    # Let's try a simpler approach first without lookbehind, relying on pattern order.
    # Begin on a line that starts with the required block indentation
    begin: '^(?=(\s{4,}))' # Positive lookahead captures the indentation pattern (Group 1) but doesn't consume text
    # End *before* a line that does NOT have the same indentation level (or EOF)
    # We need to match the indentation captured in 'begin' (tricky!)
    # Easier end: End *before* a line that doesn't start with 4+ spaces
    end: '^(?!\s{4,})' # Negative lookahead: End if the line doesn't start with 4+ spaces
    # --- Alternative/Simpler End: Might be less precise if blank lines allowed ---
    # end: '^(?=\s*$|\S)' # End on an empty line or a line starting with non-space

    patterns: # Patterns to apply line-by-line *within* this begin/end block
      - include: '#interpolated_variable' # <<< Apply variable rule inside the block

  # Rule for interpolated variables like $Variable.Path.SubPath
  interpolated_variable:
    # Apply this scope to the entire matched variable expression
    name: meta.variable.interpolation.osf
    # Regex Breakdown:
    #  (\$)                         -> Group 1: The '$' symbol
    #  ([a-zA-Z_][a-zA-Z0-9_]*)      -> Group 2: The first identifier (e.g., DarinaLautner)
    #  (                           -> Group 3: Repeating group for subsequent parts
    #    (\.)                      -> Group 4: The dot separator
    #    ([a-zA-Z_][a-zA-Z0-9_]*)   -> Group 5: The subsequent identifier (e.g., meta, fullName...)
    #  )*                          -> Group 3 repeated zero or more times
    match: '(\$)([a-zA-Z_][a-zA-Z0-9_]*)((?:\.)([a-zA-Z_][a-zA-Z0-9_]*))*'
    captures:
      # Capture Group 1: The '$' sign
      '1': { name: entity.name.type.class.osf }
      '2': { name: entity.name.type.class.osf }           # <<< Style DarinaLautner as class/type
      '3': { name: variable.other.property.osf }   # <<< Style the '.' separator
      '4': { name: variable.other.property.osf }  

  strings:
    name: string.quoted.double.osf
    begin: '"'
    end: '"'
    patterns:
      - name: constant.character.escape.osf
        match: \\.

